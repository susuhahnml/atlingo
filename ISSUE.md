## ISSUE: Generating Fisher-Lander Closure from a reified output.

#### Case for obtaining simple subformulas
Lets say we have a formula from $LTL_f$ $\varphi = \circ \Diamond a$. And we want to generate all subformulas $sub(\varphi)=\{\circ \Diamond a, \Diamond a, a \}$ using ASP. 

##### :white_check_mark: Simple approach representing formula with predicates 
This definition can be easily extended for the full syntax of $LTL_f$
```
formula(next(eventually(a))).
subformula(X):-formula(X).
subformula(X):-subformula(next(X)).
subformula(X):-subformula(eventually(X)).
```

##### :white_check_mark: Using a theory

If we use a theory we can define the syntax it as follows:
```
#theory tel {
    formula_body  {
        >   : 5, unary;         % next
        >?  : 6, unary          % eventually
    };
    &tel/0 : formula_body, body
}.
:-&tel{> >? a()}.
```

Then we use the option `--output=reify` to inspect the elements of the formula.

```
...
theory_string(3,"a").
theory_tuple(0).
theory_function(4,3,0).


theory_string(2,">?").
theory_tuple(1).
theory_tuple(1,0,4).
theory_function(5,2,1).


theory_string(1,">").
theory_tuple(2).
theory_tuple(2,0,5).
theory_function(6,1,2).
...
```

The reification process assigns an identifier to every function in the first argument in the predicate `theory_function`. The subformula $id(a)=4$, $id(\Diamond a)=5$, $id(\circ \Diamond a)=5$. With this process we can identify each subformula as a number and use it for some application (In my case each sub formula as a state of an automaton). Here I include the parenthesis for predicates so that they also apear in this predicate.




#### Fisher-Lander Closure

Now lets say we want the [Fisher-Lander Closure](https://books.google.de/books?id=56bWrsX1xH8C&pg=PA77&lpg=PA77&dq=Fisher-Lander+closure&source=bl&ots=PF-La6XXU9&sig=ACfU3U0_lQ-sj828bvxJnodJXOYaDI_SVA&hl=en&sa=X&ved=2ahUKEwiW-dKu2bbpAhXDzKQKHTQSB0EQ6AEwAHoECAoQAQ#v=onepage&q=Fisher-Lander%20closure&f=false) (FLC) of a $LDL_f $formula instead of just subformulas.
The FLC of a formula $\varphi$ is a set of $LDL_f$ formulas.The required part of the inductive definition for our example is:
- $<\rho_1;\rho_2>\psi \in CL_{\varphi}$ then $<\rho_1><\rho_2>\psi \in CL_{\varphi}$
- $<\rho>\psi \in CL_{\varphi}$ then $\psi\in CL_{\varphi}$
- $<\phi>\psi \in CL_{\varphi}$ then $\phi\in CL_{\varphi}$ ($\phi$ is propositional)
  
Following this definition with $\varphi = <a;b>c$ then $CL_{\varphi}=\{<a><b>c,<b>c,a,b,c\}$.

##### :white_check_mark: Simple approach representing formula with predicates

This definition can be easily extended for the full syntax of $LDL_f$
```
formula(diamond(sequence(prop(a),prop(b)),prop(c))).
subformula(X):-formula(X).
subformula(diamond(X,diamond(Y,Z))):-subformula(diamond(sequence(X,Y),Z)).
subformula(Z):-subformula(diamond(_,Z)).
subformula(X):-subformula(diamond(prop(X),Z)).
```


##### :x: Using a theory

If we use a theory we can define the syntax it as follows:
```
#theory del {
    formula_body  {
        ;;  : 1, binary, left;  % sequence
        .>? : 0, binary, right % diamond (eventually)
    };
    &del/0 : formula_body, body
}.

:-&del{a();;b().>?c()}.
```

And we get the reified output:

```
...
theory_string(3,"a").
theory_tuple(0).
theory_function(4,3,0).

theory_string(5,"b").
theory_function(6,5,0).

theory_string(2,";;").
theory_tuple(1).
theory_tuple(1,0,4).
theory_tuple(1,1,6).
theory_function(7,2,1).

theory_string(8,"c").
theory_function(9,8,0).

theory_string(1,".>?").
theory_tuple(2).
theory_tuple(2,0,7).
theory_tuple(2,1,9).
theory_function(10,1,2).
...
```

Now the ids no longer correspond to out target formulas :heavy_exclamation_mark:
#### How can we identify subformulas from the FLC from a reified output of a theory atom?

##### :x: Use a numeric id  

Since they are not longer generated by the reification process we would need to generate numeric ids on the go using an ASP encoding. This is not possible.

##### :x: Transform the reified output back to some predicate format

The following code would work just for our specific formula
```

operator(";;").
operator(".>?").

% Use the id for propositions and add to flc
flc(prop(ID)):- theory_function(ID,ID_O,ID_T),
                theory_string(ID_O,P), not operator(P).

% Add initial formula
flc(dimond(sequence(prop(ID_LHS_L),flc(prop(ID_RHS_L))),flc(prop(ID_RHS)))):- 
                theory_function(ID,ID_O,ID_T),
                theory_string(ID_O,".>?"),
                theory_tuple(ID_T,0,ID_LHS),
                theory_tuple(ID_T,1,ID_RHS),
                
                %We would have to keep unfolding indefinitely for left and right side
                theory_function(ID_LHS,ID_O_LSH,ID_T_LHS),
                theory_string(ID_O_LHS,";;"),
                theory_tuple(ID_T_LHS,0,ID_LHS_L),
                theory_tuple(ID_T_LHS,1,ID_RHS_L),

                %This would be the base case for our example but where should we stop?
                flc(prop(ID_LHS_L)),
                flc(prop(ID_RHS_L)),
                flc(prop(ID_RHS)).
```

Since we can't unfold the initial state we should represent it in another that does not require this.


##### :x: Identify the state by the operator LHS and RHS

If we identify a formula in the flc by the operator, the id of the left side and the id of the right side.

```
% Initial formula <a;b>c
flc(".>?",ID_LHS,LD_RHS):- 
                theory_function(ID,ID_O,ID_T),
                theory_string(ID_O,".>?"),
                theory_tuple(ID_T,0,ID_LHS),
                theory_tuple(ID_T,1,ID_RHS).

% Add formula <a><b>c to the closure
flc(".>?",ID_LHS_L,?????):-
                flc(".>?",ID_LHS,LD_RHS),
                theory_function(ID_LHS,ID_O_LSH,ID_T_LHS),
                theory_string(ID_O_LHS,";;"),
                theory_tuple(ID_T_LHS,0,ID_LHS_L),
                theory_tuple(ID_T_LHS,1,ID_RHS_L).
```

We would go back to the id problem since we don't have an id to define the right hand side $<b>c$ because it is also not a normal subformula.

##### :x: Have the Fisher-Lander closure as other theory atom

```
:-&del{a();;b().>?c()}.
&del{a().>?b().>?c()}.
&del{b().>?c()}.
```

This would give ids to all formulas in the FLC, however it is not computing the closure but the user has to write it. 

If we want to generate this theory atoms automaticaly we fall into the same problem again. If we can generate them they we would have already created the formulas.


<span style="color:red">
Is there a way to generate the FLC using the reified output of a theory atom using only ASP, or do we need to use an python program?
</span>